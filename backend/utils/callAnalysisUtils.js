const supabase = require('./supabaseClient');

/**
 * Parse success evaluation to determine call outcome
 * @param {string} successEvalValue - The success evaluation text from Vapi
 * @returns {object} - { status: string, reason: string, isSuccessful: boolean, isEmergency: boolean }
 */
function parseSuccessEvaluation(successEvalValue) {
  if (!successEvalValue || typeof successEvalValue !== 'string') {
    return {
      status: 'incomplete',
      reason: 'No success evaluation provided',
      isSuccessful: false,
      isEmergency: false
    };
  }

  const evalText = successEvalValue.toLowerCase();
  
  const emergencyIndicators = [
    'emergency declared',
    'emergency',
    'urgent medical attention',
    'immediate care required',
    'call 911',
    'emergency situation'
  ];
  
  const hasEmergencyIndicators = emergencyIndicators.some(indicator => 
    evalText.includes(indicator)
  );
  
  if (hasEmergencyIndicators) {
    return {
      status: 'emergency_declared',
      reason: 'Emergency situation identified during screening',
      isSuccessful: false,
      isEmergency: true
    };
  }
  
  const successIndicators = [
    'successful',
    'successfully',
    'completed successfully',
    'gathered the necessary information',
    'all required areas',
    'screening complete',
    'ready for appointment'
  ];
  
  const failureIndicators = [
    'unsuccessful',
    'failed',
    'incomplete',
    'missing information',
    'unclear',
    'insufficient',
    'requires rescreening',
    'incomplete screening'
  ];
  
  const hasSuccessIndicators = successIndicators.some(indicator => 
    evalText.includes(indicator)
  );
  
  const hasFailureIndicators = failureIndicators.some(indicator => 
    evalText.includes(indicator)
  );
  
  if (hasSuccessIndicators && !hasFailureIndicators) {
    return {
      status: 'successful',
      reason: 'Pre-screening completed successfully',
      isSuccessful: true,
      isEmergency: false
    };
  } else if (hasFailureIndicators) {
    return {
      status: 'failed',
      reason: 'Pre-screening incomplete - requires retry',
      isSuccessful: false,
      isEmergency: false
    };
  } else {
    return {
      status: 'incomplete',
      reason: successEvalValue,
      isSuccessful: false,
      isEmergency: false
    };
  }
}

/**
 * Extract patient ID from call analysis or structured data
 * @param {object} analysisResult - The analysis result object
 * @param {object} call - The call object from Vapi
 * @returns {string} - Verified patient ID
 * @throws {Error} - If no patient ID is found
 */
function extractPatientId(analysisResult, call) {
  if (call.metadata?.patientId) {
    console.log('[Extract] Found patientId in call metadata:', call.metadata.patientId);
    return call.metadata.patientId;
  }
  
  if (analysisResult.structuredData?.patientId) {
    console.log('[Extract] Found patientId in structuredData:', analysisResult.structuredData.patientId);
    return analysisResult.structuredData.patientId;
  }
  
  console.error('[Extract] No patientId found for call:', call.id);
  throw new Error('Missing patientId: Identity verification should have provided a patientId');
}

/**
 * Extract appointment ID from call analysis or structured data
 * @param {object} analysisResult - The analysis result object
 * @param {object} call - The call object from Vapi
 * @returns {string|null} - Appointment ID if found
 */
function extractAppointmentId(analysisResult, call) {
  if (analysisResult.structuredData?.appointmentId) {
    return analysisResult.structuredData.appointmentId;
  }
  
  if (call.metadata?.appointmentId) {
    return call.metadata.appointmentId;
  }
  
  return null;
}

/**
 * Save call analysis to Supabase database - SAVES ALL CALLS WITH VERIFIED PATIENT ID
 * @param {object} callData - The complete call data from Vapi
 * @param {object} analysisResult - The processed analysis result
 * @returns {object} - Database operation result
 */
async function saveCallAnalysis(callData, analysisResult) {
  try {
    console.log('[Database] Preparing to save call analysis for call:', callData.id);
    
    const successEvaluation = parseSuccessEvaluation(analysisResult.successEvaluation?.value);
    
    const patientId = extractPatientId(analysisResult, callData);
    const appointmentId = extractAppointmentId(analysisResult, callData);
    
    console.log('[Database] Call evaluation results:', {
      callId: callData.id,
      status: successEvaluation.status,
      isSuccessful: successEvaluation.isSuccessful,
      isEmergency: successEvaluation.isEmergency,
      patientId,
      appointmentId,
      hasSummary: !!analysisResult.summary,
      hasStructuredData: !!analysisResult.structuredData
    });
    
    const insertData = {
      id: callData.id, // UUID generated by gen_random_uuid()
      call_id: callData.id,
      patient_id: patientId, // Verified patientId
      appointment_id: appointmentId,
      call_summary: analysisResult.summary || 'No summary available',
      structured_data: analysisResult.structuredData || {},
      success_evaluation: successEvaluation.status, // Text status
      success_rubric: analysisResult.successEvaluation?.value || successEvaluation.reason, // Full Vapi reason
      is_emergency: successEvaluation.isEmergency, // New column
      call_transcript: callData.transcript || null,
      call_duration: callData.duration || null,
      analysis_timestamp: callData.endedAt ? new Date(callData.endedAt) : new Date(),
      created_at: new Date()
    };
    
    console.log('[Database] Inserting call analysis:', {
      callId: insertData.call_id,
      patientId: insertData.patient_id,
      appointmentId: insertData.appointment_id || 'NOT_PROVIDED',
      evaluationStatus: insertData.success_evaluation,
      successRubricLength: insertData.success_rubric?.length || 0,
      isEmergency: insertData.is_emergency,
      hasSummary: !!insertData.call_summary,
      hasStructuredData: !!insertData.structured_data
    });
    
    const { data, error } = await supabase
      .from('call_analysis')
      .insert([insertData])
      .select();
    
    if (error) {
      console.error('[Database] Supabase insert error:', error);
      throw error;
    }
    
    console.log('[Database] Call analysis saved successfully:', data[0].id);
    
    return {
      success: true,
      data: data[0],
      evaluationStatus: successEvaluation.status,
      isSuccessful: successEvaluation.isSuccessful,
      isEmergency: successEvaluation.isEmergency,
      reason: successEvaluation.reason
    };
    
  } catch (error) {
    console.error('[Database] Error saving call analysis:', error);
    return {
      success: false,
      error: error.message,
      evaluationStatus: successEvaluation.status,
      isSuccessful: successEvaluation.isSuccessful,
      isEmergency: successEvaluation.isEmergency,
      reason: successEvaluation.reason || 'Database error occurred'
    };
  }
}

/**
 * Check if call analysis already exists
 * @param {string} callId - The call ID to check
 * @returns {boolean} - True if exists, false otherwise
 */
async function callAnalysisExists(callId) {
  try {
    const { data, error } = await supabase
      .from('call_analysis')
      .select('id')
      .eq('call_id', callId)
      .single();
    
    if (error && error.code !== 'PGRST116') {
      console.error('[Database] Error checking call analysis existence:', error);
      return false;
    }
    
    return !!data;
  } catch (error) {
    console.error('[Database] Error checking call analysis existence:', error);
    return false;
  }
}

/**
 * Get call analysis by call ID
 * @param {string} callId - The call ID to retrieve
 * @returns {object|null} - Call analysis data or null
 */
async function getCallAnalysis(callId) {
  try {
    const { data, error } = await supabase
      .from('call_analysis')
      .select('*')
      .eq('call_id', callId)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') {
        return null;
      }
      throw error;
    }
    
    return data;
  } catch (error) {
    console.error('[Database] Error retrieving call analysis:', error);
    return null;
  }
}

/**
 * Update appointment status based on call outcome
 * @param {string} appointmentId - The appointment ID
 * @param {string} status - New status ('confirmed', 'cancelled', 'requires_rescreening')
 * @param {string} reason - Reason for status change
 * @returns {object} - Update result
 */
async function updateAppointmentStatus(appointmentId, status, reason) {
  try {
    if (!appointmentId) {
      return { success: false, error: 'No appointment ID provided' };
    }

    const { data, error } = await supabase
      .from('appointments')
      .update({
        status: status,
        status_reason: reason,
        updated_at: new Date().toISOString()
      })
      .eq('id', appointmentId)
      .select();

    if (error) {
      console.error('[Database] Error updating appointment status:', error);
      throw error;
    }

    console.log(`[Database] Appointment ${appointmentId} status updated to: ${status}`);
    return { success: true, data: data[0] };

  } catch (error) {
    console.error('[Database] Error updating appointment status:', error);
    return { success: false, error: error.message };
  }
}

module.exports = {
  saveCallAnalysis,
  callAnalysisExists,
  getCallAnalysis,
  parseSuccessEvaluation,
  extractPatientId,
  extractAppointmentId,
  updateAppointmentStatus
};
